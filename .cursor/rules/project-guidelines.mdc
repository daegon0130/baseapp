

```markdown
# BaseApp 프로젝트 커서 룰

## 프로젝트 개요
- **프레임워크**: Flutter
- **앱 이름**: BaseApp
- **상태 관리**: Provider
- **라우팅**: GoRouter
- **주요 기술 스택**: flutter_dotenv, google_fonts, permission_handler, intl

## 아키텍처 및 디렉토리 구조

프로젝트는 레이어드 아키텍처를 따르며, 다음과 같은 디렉토리 구조를 유지합니다:

```
lib/
├── clients/     # 외부 서비스와의 통신 (API, Database 등)
├── models/      # 데이터 모델 및 엔티티
├── screens/     # 화면 UI 구성
├── services/    # 비즈니스 로직 처리
├── states/      # Provider 기반 상태 관리
├── theme/       # 디자인 시스템 및 테마 정의
├── utils/       # 헬퍼 함수 및 유틸리티
├── widgets/     # 재사용 가능한 공통 위젯
├── main.dart    # 앱 진입점
└── router.dart  # 라우팅 설정
```

## 코딩 규칙

### 1. 파일 및 네이밍 컨벤션
- **파일명**: snake_case 사용 (예: `home_screen.dart`, `user_service.dart`)
- **클래스명**: PascalCase 사용 (예: `HomeScreen`, `UserService`)
- **변수/함수명**: camelCase 사용 (예: `userName`, `fetchUserData()`)
- **상수명**: lowerCamelCase 또는 UPPER_SNAKE_CASE (예: `kPrimaryColor` 또는 `MAX_RETRY_COUNT`)

### 2. 위젯 작성 규칙
- 모든 화면 위젯은 `screens/` 디렉토리에 배치하고 `Screen` 접미사 사용
- 재사용 가능한 위젯은 `widgets/` 디렉토리에 배치
- StatelessWidget을 우선 사용하고, 필요한 경우에만 StatefulWidget 사용
- 위젯은 const 생성자를 최대한 활용하여 성능 최적화

```dart
// Good
class HomeScreen extends StatelessWidget {
  const HomeScreen({super.key});
  
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      // ...
    );
  }
}
```

### 3. 상태 관리 (Provider)
- 모든 상태 클래스는 `states/` 디렉토리에 배치
- `ChangeNotifier`를 상속하여 상태 관리 클래스 작성
- 상태 클래스명은 `State`, `Provider`, 또는 `Notifier` 접미사 사용

```dart
// Good
class UserState extends ChangeNotifier {
  User? _user;
  
  User? get user => _user;
  
  void setUser(User user) {
    _user = user;
    notifyListeners();
  }
}
```

### 4. 라우팅 (GoRouter)
- 모든 라우팅 설정은 `router.dart`에 중앙화
- 라우트 경로는 명확하고 RESTful한 구조 사용
- 네임드 라우트 사용을 권장

```dart
// Good
final router = GoRouter(
  initialLocation: '/',
  routes: [
    GoRoute(
      path: '/',
      name: 'home',
      builder: (context, state) => const HomeScreen(),
    ),
    GoRoute(
      path: '/profile/:id',
      name: 'profile',
      builder: (context, state) {
        final id = state.pathParameters['id']!;
        return ProfileScreen(userId: id);
      },
    ),
  ],
);
```

### 5. 모델 작성 규칙
- 모든 데이터 모델은 `models/` 디렉토리에 배치
- immutable 클래스로 작성 (모든 필드 final)
- JSON 직렬화/역직렬화 메서드 포함 (`fromJson`, `toJson`)
- copyWith 메서드 제공 권장

```dart
// Good
class User {
  final String id;
  final String name;
  final String email;
  
  const User({
    required this.id,
    required this.name,
    required this.email,
  });
  
  factory User.fromJson(Map<String, dynamic> json) {
    return User(
      id: json['id'] as String,
      name: json['name'] as String,
      email: json['email'] as String,
    );
  }
  
  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'name': name,
      'email': email,
    };
  }
  
  User copyWith({String? name, String? email}) {
    return User(
      id: id,
      name: name ?? this.name,
      email: email ?? this.email,
    );
  }
}
```

### 6. 서비스 레이어 규칙
- 비즈니스 로직은 `services/` 디렉토리에 배치
- 서비스 클래스명은 `Service` 접미사 사용
- 단일 책임 원칙 준수 (각 서비스는 하나의 도메인만 담당)

```dart
// Good
class AuthService {
  Future<User> login(String email, String password) async {
    // 로그인 로직
  }
  
  Future<void> logout() async {
    // 로그아웃 로직
  }
}
```

### 7. 클라이언트 레이어 규칙
- 외부 API/Database 통신 코드는 `clients/` 디렉토리에 배치
- 클라이언트 클래스명은 `Client` 접미사 사용
- HTTP 통신, 로컬 DB 접근 등 외부 리소스 통신 담당

```dart
// Good
class ApiClient {
  final String baseUrl;
  
  ApiClient({required this.baseUrl});
  
  Future<Map<String, dynamic>> get(String endpoint) async {
    // HTTP GET 요청
  }
  
  Future<Map<String, dynamic>> post(String endpoint, Map<String, dynamic> data) async {
    // HTTP POST 요청
  }
}
```

### 8. 테마 및 스타일링
- 모든 테마 설정은 `theme/` 디렉토리에 배치
- Google Fonts 사용 시 일관된 폰트 적용
- 색상 상수는 테마 파일에서 관리
- Material Design 가이드라인 준수

```dart
// Good - theme/app_theme.dart
class AppTheme {
  static const Color primaryColor = Color(0xFF6200EE);
  static const Color secondaryColor = Color(0xFF03DAC6);
  
  static ThemeData get lightTheme {
    return ThemeData(
      colorScheme: ColorScheme.fromSeed(seedColor: primaryColor),
      textTheme: GoogleFonts.robotoTextTheme(),
    );
  }
}
```

### 9. 에러 처리
- try-catch 블록을 적절히 사용하여 에러 처리
- 사용자에게 명확한 에러 메시지 제공
- 로깅을 통한 디버깅 정보 제공

```dart
// Good
Future<User> fetchUser(String id) async {
  try {
    final response = await apiClient.get('/users/$id');
    return User.fromJson(response);
  } catch (e) {
    debugPrint('Failed to fetch user: $e');
    rethrow;
  }
}
```

### 10. 비동기 처리
- `async`/`await` 사용 권장
- `FutureBuilder` 또는 `StreamBuilder` 활용
- 로딩 상태 및 에러 상태 UI 제공

### 11. 환경 변수 관리
- `.env` 파일을 사용하여 환경 변수 관리
- API 키, 엔드포인트 등 민감한 정보는 `.env`에 저장
- `.env` 파일은 `.gitignore`에 추가

### 12. 권한 처리
- `permission_handler` 패키지 사용
- 권한 요청 로직은 `services/` 또는 `utils/`에 분리
- 사용자에게 권한이 필요한 이유 명확히 설명

### 13. 국제화 (i18n)
- `intl` 패키지를 사용한 다국어 지원
- 하드코딩된 문자열 사용 금지
- 모든 사용자 대면 텍스트는 지역화 가능하게 작성

## 코드 품질 및 베스트 프랙티스

### 1. 코드 포맷팅
- `flutter format` 명령어로 코드 포맷팅 유지
- `analysis_options.yaml`에 정의된 린트 규칙 준수

### 2. 주석 작성
- 복잡한 로직에는 주석 추가
- 공개 API에는 문서 주석(`///`) 작성
- TODO 주석은 이슈 트래킹 시스템과 연동

### 3. 테스트
- `test/` 디렉토리에 유닛 테스트 및 위젯 테스트 작성
- 핵심 비즈니스 로직은 반드시 테스트 작성
- 테스트 커버리지 유지

### 4. 성능 최적화
- 불필요한 rebuild 방지 (`const` 위젯 사용)
- 큰 리스트는 `ListView.builder` 사용
- 이미지 최적화 및 캐싱

### 5. 보안
- 민감한 정보는 코드에 하드코딩 금지
- 사용자 데이터는 안전하게 저장 및 전송
- HTTPS 사용 필수

## 앱 아이콘 및 스플래시 화면

### 앱 아이콘 적용
1. `assets/icons/icon.png`에 아이콘 이미지 추가
2. 명령어 실행: `flutter pub run flutter_launcher_icons`

### 스플래시 화면 적용
1. `assets/icons/splash12.png`에 스플래시 이미지 추가
2. 명령어 실행: `flutter pub run flutter_native_splash:create`

### 스플래시 화면 변경
```bash
flutter pub run flutter_native_splash:remove
flutter clean
flutter pub get
flutter pub run flutter_native_splash:create
```

## Git 커밋 컨벤션

- `feat:` 새로운 기능 추가
- `fix:` 버그 수정
- `docs:` 문서 수정
- `style:` 코드 포맷팅, 세미콜론 누락 등
- `refactor:` 코드 리팩토링
- `test:` 테스트 코드 추가/수정
- `chore:` 빌드 업무 수정, 패키지 매니저 수정 등

## 개발 워크플로우

1. 새로운 기능 개발 시 feature 브랜치 생성
2. 코드 작성 및 테스트
3. `flutter analyze` 실행하여 린트 에러 확인
4. `flutter test` 실행하여 테스트 통과 확인
5. Pull Request 생성 및 코드 리뷰
6. main 브랜치에 머지

## 의존성 관리

- `pubspec.yaml`에 명시적으로 버전 관리
- 주기적으로 `flutter pub outdated` 실행하여 업데이트 확인
- 메이저 버전 업데이트 시 충분한 테스트 수행
